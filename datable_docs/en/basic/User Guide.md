# User Guide

> æ¥æº: https://www.datable.cn/en/docs/basic

## [ğŸ“„ï¸ Differences from the classic versionCompared with the classic version, the current version greatly simplifies the code implementation and is more convenient for customization. So the code adjustment is huge, but the usage difference is not huge.](../manual/Differences from the classic version.md)## [ğŸ“„ï¸ design philosophyIn most people's minds, the implementation of configuration tools should be very simple. In fact, you can implement a simple configuration tool with a few hundred lines of code, but it is only usable and far from meeting the various requirements of the configuration workflow in actual game projects.](../manual/design philosophy.md)## [ğŸ“„ï¸ FeaturesLuban has a wealth of built-in features.](../manual/Features.md)## [ğŸ“„ï¸ luban.confDefines the global configuration required by luban.](../manual/luban.conf.md)## [ğŸ“„ï¸ schema logical structureAs introduced in the Design Philosophy document, the core of Luban is a complete type system, and the DPP pipeline is the basis for powerful expansion capabilities.](../manual/schema logical structure.md)## [ğŸ“„ï¸ configuration definitionLuban has a set of Schema logical structure implementation independent of the specific implementation. There is no requirement on how to define the configuration, as long as the final definition can be loaded and parsed into a schema logical structure, it can be processed uniformly. The Luban.Schema.Builtin module provides a default SchemaCollector implementation. If the requirements cannot be met, developers can implement a custom SchemaCollector to suit their own project needs.](../manual/configuration definition.md)## [ğŸ“„ï¸ Auto-Imported TableEach new table is added to tables.xlsx, which is a tedious task. In most cases, each excel corresponds to a table, and it is possible to let the tool automatically add the table definition.](../manual/Auto-Imported Table.md)## [ğŸ“„ï¸ Command line toolsCross-platform](../manual/Command line tools.md)## [ğŸ“„ï¸ Hierarchical parameter mechanismMost of Luban's built-in templates use the Cascading Option mechanism, which reduces the module name step by step until the option is found.](../manual/Hierarchical parameter mechanism.md)## [ğŸ“„ï¸ type systemLuban has a complete type system, especially bean supports type inheritance and polymorphism, so that Luban can easily express any complex data structure.](../manual/type system.md)## [ğŸ“„ï¸ type mappingSometimes you want to use ready-made struct types directly in the generated code instead of using the generated type code. For example, vector3 is a very common type. After you define vector3 in the configuration, you may want to use UnityEngine.Vector3 instead of the generated vector3 class where the vector3 type is involved in the generated C# code. Luban supports this external type mapping mechanism, which can map configuration classes to external ready-made enum or class types.](../manual/type mapping.md)## [ğŸ“„ï¸ Excel Format (Primary)Basic rules](../manual/Excel Format (Primary).md)## [ğŸ“„ï¸ Excel Format (Advanced)Structure used in the example](../manual/Excel Format (Advanced).md)## [ğŸ“„ï¸ Excel compact formatIntroduction](../manual/Excel compact format.md)## [ğŸ“„ï¸ Non-Excel data sourceNot all configuration data is saved in Excel format. In actual projects, some complex configurations are generated by editors, which are generally saved in formats such as json or xml. luban currently](../manual/Non-Excel data source.md)## [ğŸ“„ï¸ Code and Data GenerationSupport mainstream game engines and platforms](../manual/Code and Data Generation.md)## [ğŸ“„ï¸ Code StyleLuban generates code for a language that conforms to the recommended style of the language by default, but sometimes developers want to control the generated code style. Luban](../manual/Code Style.md)## [ğŸ“„ï¸ Load configurationInstall Luban.Runtime](../manual/Load configuration.md)## [ğŸ“„ï¸ data validatorA variety of common data validators are implemented in the Luban.DataValidtor.Builtin module.](../manual/data validator.md)## [ğŸ“„ï¸ custom templateLuban uses the scriban template engine to generate code, and also uses this template to generate custom text data files.](../manual/custom template.md)## [ğŸ“„ï¸ data tagLuban supports record-level tag marking, and each data can have 0 or more tags. tag can be used to identify a record as a comment, either to filter the export, or to instruct the validator not to check this record.](../manual/data tag.md)## [ğŸ“„ï¸ Field VariantsSometimes the same field may have multiple configurations. A very common scenario is that when making localized data, different regions have different values â€‹â€‹for a certain initial path.](../manual/Field Variants.md)## [ğŸ“„ï¸ localizationMultiple localization mechanisms are supported and they can be used simultaneously.](../manual/localization.md)## [ğŸ“„ï¸ Best PracticesNaming Conventions](../manual/Best Practices.md)## [ğŸ“„ï¸ Extended Luban implementationAfter weighing flexibility and simplicity, luban does not use the plug-in mechanism, but adds some extension projects to the source code project to achieve extension.](../manual/Extended Luban implementation.md)

