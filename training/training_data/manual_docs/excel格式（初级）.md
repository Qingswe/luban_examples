# excel格式（初级）

> 来源: https://www.datable.cn/docs/manual/excel

  * [](/)
  * [使用指南](../basic/使用指南.md)
  * excel格式（初级）

版本：4.x

本页总览

# excel格式（初级）

## 基础规则​

### 支持的excel文件族​

支持 xls、 xlsx、 xlm、 xlmx、csv 。基本上excel能打开的都可以读取。

### excel文件 读取规则​

  * 如果未指定sheet，则默认会读取所有sheet
  * 可以用 [sheet@xxx.xlsx](mailto:sheet@xxx.xlsx) 指定只读入这个sheet数据
  * 如果A1单元格数据不以##开头，则会被当作非数据sheet，被忽略



### 读取除GKB和UTF8以外编码的csv文件​

luban会智能猜测出它的编码，正确处理。

### 灵活的文件组织形式​

  * 可以几个表都放到一个xlsx中，每个表占一个sheet。 只需要为每个表的input指定为该单元薄即可，如`xxx@item/test/abs.xlsx`
  * 可以一个表拆分为几个xlsx。 如 `item/a.xlsx,bag/b.xlsx,c.xlsx`
  * 可以一个读入一个目录下的所有xlsx。 如 `xlsx_files` 。



## 标题头行格式​

一个典型的配置表示例：

| ##var | id | name | desc | count | |
| ---- | ---- | ---- | ---- | ---- | ---- |
| ##type | int | string | string | int | |
| ##group | | c | s | c,s | |
| ## | id | 名称 | 描述 | 个数 | |
| | 1001 | 奖励1 | 碎片 | 100 | |
| | 1002 | 奖励2 | 金币 | 1000 | |

  * 第1列单元格为 `##var` 表示这行是字段定义行
  * 第1列单元格为 `##type` 表示这行是 类型定义行
  * 第1列单元格为 `##group` 表示这行是 导出分组行。**此行可选** 。另外，单元格留空表示对所有分组导出。
  * 第1列单元格以##**开头** 表示这是注释行，如果有多个##行，默认以第一个行作为代码中字段的注释，你可以通过##comment 显式指定某行为代码注释行。
  * 填写多级字段名行时，以##var表示这是次级字段行
  * 你可以随意调整以`##<name>`开头的行的顺序。例如`##var`行与`##group`行调换顺序，完全不影响最终结果



## 注释行或列​

当标题行字段名为空或者以'#'开头时，这个列会被当作注释列而忽略。当数据行的第一列以##开头时，这一行会被当作注释行而被忽略。

| ##var | id | name | | #count | |
| ---- | ---- | ---- | ---- | ---- | ---- |
| ##type | int | string | string | int | |
| ##group | | c | s | c,s | |
| ## | id | 名称 | 描述 | 个数 | |
| | 1001 | 奖励1 | 碎片 | 100 | |
| | 1002 | 奖励2 | 金币 | 1000 | |
| ## | 1003 | 奖励3 | 金币 | 1001 | |
| | 1004 | 奖励4 | 金币 | 1002 | |

以上示例中，D列和E列被注释而忽略，第7行由于以##开头，也被注释而不会导出。

## 基础数据格式​

如下图所示，数据填法基本与常识相符。

| ##var | id | x1 | x2 | x3 | x4 | x5 | x6 | x7 | x8 | x8_escaped | x9 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| ##type | int | bool | byte | short | int | long | float | double | string | string#escape=1 | datetime |
| ##group | | c | s | c,s | | | | | | | |
| ## | id | | | | | | | | | 转义字符串 | |
| | 1001 | TRUE | | 1 | 100 | 10000 | 10000 | 12.5 | 112233.5 | hello | abc\ndef\nxxx | 1999-09-09 00:00:00 |
| | 1002 | FALSE | | 2 | 101 | 10001 | 10001 | 13.5 | 112234.5 | hello | abc\ndef\nxxx | 1999-09-09 00:00:01 |
| | 1003 | True | | 3 | 102 | 10002 | 10002 | 14.5 | 112235.5 | hello | aaa\t\tbbb | 1999-09-09 00:00:02 |
| | 1004 | 0 | | 4 | 103 | 10003 | 10003 | 15.5 | 112236.5 | hello | hello | 1999-09-09 00:00:03 |
| | 1005 | 1 | | 5 | 104 | 10004 | 10004 | 16.5 | 112237.5 | hello | hello | 1999-09-09 00:00:04 |
| | 1006 | | | | | | | | | | 1999-09-09 00:00:05 |

特殊说明：

  * bool： `true、false、0、1、是、否` 都是有效值。另外大小写不敏感，如True也是合法bool值。填其他值如abc、4则会发生解析错误
  * string：单元格留空即为长度为0的字符串。但读取流式格式时，空白单元格也会被当作无用单元格而被忽略，此时可以用`""`表示长度为0的字符串。string默认不处理转义， 如果希望将字符串中`\n`替换为换行符，则需要添加上`escape=1`tag，如`string#escape=1`。
  * datetime支持以下几种格式
    * excel中的内置日期格式
    * yyyy-mm-dd hh:mm:ss 字符串格式
    * yyyy-mm-dd hh:mm 字符串格式。此时秒自动取0
    * yyyy-mm-dd hh 字符串格式。此时分与秒取0
    * yyyy-mm-dd 字符串格式。此时时分秒都取0



**除了datetime以外的基础数据格式都可以留空** ，自动取默认值，如第10行所示。

## enum 数据格式​

可以填写枚举项的变量名、别名或者对应的整数。如果是flags类型枚举，还可以填'A|B'这样的或形式枚举。flags类型enum还支持列限定模式， 让每个枚举值占一列，然后将包含的标志位列标为1，表示最终的枚举值包含此项。

| ##var | id | x1 | x2 | x3 | x3 | x3 | x3 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| ##type | int | Quality | AccessFlag | AccessFlag | AccessFlag | AccessFlag | AccessFlag |
| ##var | | | | READ | WRITE | APPEND | TRUNCT |
| ##group | | c | s | | | | |
| ## | id | | | | | | |
| | 1001 | RED | READ | 1 | | 1 | |
| | 1002 | WHITE | WRITE | | 1 | | 1 |
| | 1003 | 红 | READ\|WRITE | 1 | | | |
| | 1004 | 1 | 读 | | 1 | | |
| | 1005 | 2 | 写 | 1 | 1 | 1 | 1 |
| | 1006 | 红 | | 6 | | | |
| | 1007 | 红 | | 7 | 1 | | |

如果enum中有值为0的枚举项，则可以留空，自动取该枚举项，否则会解析出错。

对于flags类型的enum，允许填多个枚举值来表示组合，默认使用'|'来分割多个枚举值。可以通过设置enum的sep属性来指定其他分割符。如`sep=","`时，使用`A,B`表示两个枚举值的或组合。

## bean数据格式​

假设 Item是包含`int id; int count; string desc` 这三个字段的bean，item字段类型为Item。合并C1-E1为一个单元格，作为item字段范围。在item字段的列范围内， 按顺序填写Item结构的每个字段。如下图所示。

| ##var | id | | | item | item |
| ---- | ---- | ---- | ---- | ---- | ---- |
| ##type | int | | | Item | Item |
| ##group | | | | c | |
| ## | id | | | | |
| | 1 | 1001 | 10 | 道具1 | |
| | 2 | 1002 | 11 | 道具2 | |
| | 3 | 1003 | 12 | 道具3 | |
| | 4 | 1004 | 13 | 道具4 | |

如果该bean字段为多态类型，则须先填写多态类型名，再顺序填写多态类型的字段。多态类型名可以填bean的别名。如下图。

| ##var | id | shape | shape | shape | shape |
| ---- | ---- | ---- | ---- | ---- | ---- |
| ##type | int | Shape | Shape | Shape | Shape |
| ##group | | | | | |
| ## | id | | | | |
| | 1 | Circle | 10 | | |
| | 2 | Triangle | 10 | 12 | 15 |
| | 3 | 圆 | 100 | | |
| | 4 | 矩形 | 100 | 200 | |

## 容器类型​

与bean类型，通过合并单元格作为字段的列范围，在范围内填写数据即可。**空白** 单元格会被忽略。

| ##var | id | | x1 | x1 | x1 | x2 | x2 | x2 | x3 | x3 | x3 | x4 | x4 | x4 | x4 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| ##type | int | | arrary,int | arrary,int | arrary,int | list,int | list,int | list,int | set,int | set,int | set,int | map,int,string | map,int,string | map,int,string | map,int,string |
| ##group | | | | | | | | | | | | | | | |
| ## | id | | | | | | | | | | | | | | |
| | 1 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 1 | hello | | | |
| | 2 | 11 | 12 | | 14 | 15 | 16 | 17 | 18 | | 2 | hello | 4 | world | |
| | 3 | 12 | | | 15 | 16 | 17 | 18 | 19 | | 3 | abc | 6 | defg | |
| | 4 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | | | 5 | aaa | 7 | bbb | |

map以key、value为键值对，依次填写。

## 可空类型​

除了容器以外的类型都可以是可空类型。所有可空类型都可以用null表达空值。

  * 对于只包含一个数据的原子数据类型（如int），单元格留空也表达null
  * 对于string?类型，单元格留空表达null而不是长度为0的字符串。如果你想表达空白字符串请用`""`
  * 对于非多态的bean类型的可空类型，如果非空，需要以`{}`开头表示非空，接着顺序填写bean的值
  * 对于多态bean，填法不变



| id | x1 | x2 | x3 | x4 | x5 | x6 | x7 | x8 | x9 | y1 | y2 | y2 | y2 | y3 | y3 | y3 | y3 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| int | bool? | byte? | short? | int? | long? | float? | double? | string? | datetime? | Quality? | Item? | Item? | Item? | Shape? | Shape? | Shape? | Shape? |
| | c | s | c,s | | | | | | | | | | | | | | |
| id | | | | | | | | | | | | | | | | | |
| 1001 | null | null | null | null | null | null | null | null | null | null | null | | | null | | | |
| 1002 | FALSE | | 2 | 101 | 10001 | 10001 | 13.5 | 112234.5 | hello | 1999-09-09 00:00:01 | RED | {} | 1001 | 10 | 道具1 | Circle | 10 | |
| 1003 | True | | 3 | 102 | 10002 | 10002 | 14.5 | 112235.5 | hello | 1999-09-09 00:00:02 | 红 | {} | 1002 | 10 | 道具2 | 圆 | 10 | |
| 1004 | 0 | | 4 | 103 | 10003 | 10003 | 15.5 | 112236.5 | hello | 1999-09-09 00:00:03 | | 1 | {} | 1003 | 10 | 道具3 | 矩形 | 10 | 20 |
| 1005 | 1 | | 5 | 104 | 10004 | 10004 | 16.5 | 112237.5 | hello | 1999-09-09 00:00:04 | | 2 | {} | 1004 | 10 | 道具4 | Rectangle | 20 | 30 |
| 1006 | | | | | | | | | | | | | {} | 1005 | 10 | 道具5 | Rectangle | 21 | 31 |

## 无主键表​

有时候只想得到一个记录列表，无主键。mode="list"并且index为空，表示无主键表。

定义表
    
    
    <table name="TbNotKeyList" value="NotKeyList" mode="list" input="not_key_list.xlsx"/>  
    

| ##var | x | y | z | s |
| ---- | ---- | ---- | ---- | ---- |
| ##type | int | int | int | string |
| | 1 | 2 | 2 | aaa |
| | 2 | 3 | 3 | aaa |
| | 3 | 4 | 4 | aaa |
| | 4 | 5 | 5 | aaa |
| | 5 | 6 | 6 | aaa |
| | 6 | 7 | 7 | aaa |
| | 7 | 8 | 8 | aaa |
| | 8 | 9 | 9 | aaa |

## 多主键表（联合索引）​

多个key构成联合唯一主键。使用"+"分割key，表示联合关系。

定义表
    
    
    <table name="TbUnionMultiKey" value="UnionMultiKey" index="key1+key2+key3" input="union_multi_key.xlsx"/>  
    

| ##var | key1 | key2 | key3 | x |
| ---- | ---- | ---- | ---- | ---- |
| ##type | int | long | string | string |
| | 1 | 1 | aaa | 100 |
| | 1 | 1 | bbb | 100 |
| | 1 | 2 | aaa | 100 |
| | 4 | 5 | aaa | 100 |
| | 5 | 6 | aaa | 100 |
| | 6 | 7 | aaa | 100 |
| | 7 | 8 | aaa | 100 |
| | 8 | 9 | aaa | 100 |

## 多主键表（独立索引）​

多个key，各自独立唯一索引。与联合索引写法区别在于使用 ","来划分key，表示独立关系。

定义表
    
    
    <table name="TbMultiKey" value="MultiKey" index="key1,key2,key3" input="multi_key.xlsx"/>  
    

| ##var | key1 | key2 | key3 | x |
| ---- | ---- | ---- | ---- | ---- |
| ##type | int | long | string | string |
| | 1 | 10 | aaa | 100 |
| | 2 | 20 | bbb | 100 |
| | 3 | 30 | ccc | 100 |
| | 4 | 40 | eee | 100 |
| | 5 | 50 | fff | 100 |
| | 6 | 60 | ggg | 100 |
| | 7 | 70 | hhh | 100 |
| | 8 | 80 | abb | 100 |

## 单例表​

有一些配置全局只有一份，比如 公会模块的开启等级，背包初始大小，背包上限。此时使用单例表来配置这些数据比较合适。

| ##var | x1 | x2 | x3 | x4 | x5 | x5 | x5 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| ##type | int | int | int | (list#sep=\|),int | list,int | list,int | list,int |
| | 1 | 2 | 10 | 1\|2\|3 | 11 | 22 | 33 |

## 纵表​

大多数表都是横表，即一行一个记录。有些表，比如单例表，如果纵着填，一行一个字段，会比较舒服。A1为`##column`或`##vertical`表示使用纵表模式。 上面的单例表，以纵表模式填如下。

| ##column#var | ##type | ## | | |
| ---- | ---- | ---- | ---- | ---- |
| | | 描述 | 具体参数 | |
| x1 | int | 参数1 | 1101001101 | |
| x2 | int | 道具 | 150 | |
| x3 | int | | 500 | |
| x4 | int | | 50 | |
| x5 | int | | 10 | |
| x6 | int | | 4 | |
| x7 | (list#sep=\|),int | | 1\|2\|3\|4 | |
